// Copyright 2025 eraflo
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! The AssetAgent is responsible for managing asset loading and retrieval.

use anyhow::{Context, Result};
use khora_core::{
    asset::{Asset, AssetHandle, AssetUUID},
    vfs::VirtualFileSystem,
};
use khora_lanes::asset_lane::{AssetLoaderLane, PackLoadingLane};
use std::fs::File;

use crate::asset_agent::loader::AssetLoaderLaneRegistry;

/// The AssetAgent is responsible for managing asset loading and retrieval.
pub struct AssetAgent {
    /// The virtual file system for asset management.
    vfs: VirtualFileSystem,
    /// The loading lane for asset I/O operations.
    loading_lane: PackLoadingLane,
    /// The registry that manages asset loaders.
    loaders: AssetLoaderLaneRegistry,
}

impl AssetAgent {
    /// Creates a new `AssetAgent` with the given VFS and loading lane.
    pub fn new(index_bytes: &[u8], data_file: File) -> Result<Self> {
        let vfs = VirtualFileSystem::new(index_bytes)
            .context("Failed to initialize VirtualFileSystem from index bytes")?;

        let loading_lane = PackLoadingLane::new(data_file);

        Ok(Self {
            vfs,
            loading_lane,
            loaders: AssetLoaderLaneRegistry::new(),
        })
    }

    /// Registers an `AssetLoaderLane` for a specific asset type name.
    ///
    /// The `type_name` should match the one generated by the `xtask` packager
    /// based on the file extension.
    pub fn register_loader<A: Asset>(
        &mut self,
        type_name: &str,
        loader: impl AssetLoaderLane<A> + Send + Sync + 'static,
    ) {
        self.loaders.register::<A>(type_name, loader);
    }

    /// Loads, decodes, and returns a typed handle to an asset.
    ///
    /// This is the main, fully-featured loading method.
    pub fn load<A: Asset>(&mut self, uuid: &AssetUUID) -> Result<AssetHandle<A>> {
        let metadata = self.vfs.get_metadata(uuid).context("...")?;
        let source = metadata.variants.get("default").context("...")?;
        let bytes = self.loading_lane.load_asset_bytes(source)?;

        let asset = self.loaders.load::<A>(&metadata.asset_type_name, &bytes)?;

        Ok(AssetHandle::new(asset))
    }
}

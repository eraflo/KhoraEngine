
use winit::event::{WindowEvent, ElementState, MouseButton as WinitMouseButton, MouseScrollDelta};
use winit::keyboard::{KeyCode, PhysicalKey};

/// Represents different kinds of input events the engine can handle.
/// These events can be generated by various input devices such as keyboards, mice, or game controllers.
#[derive(Debug, Clone, PartialEq)]
pub enum InputEvent {
    KeyPressed { key_code: String},
    KeyReleased { key_code: String},
    MouseButtonPressed { button: MouseButton },
    MouseButtonReleased { button: MouseButton },
    MouseMoved { x: f32, y: f32 },
    MouseWheelScrolled  { delta_x: f32, delta_y: f32 },
}

/// Represents mouse buttons internally.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum MouseButton {
    Left,
    Right,
    Middle,
    Back,
    Forward,
    Other(u16),
}


/// Translates winit input events into the engine's InputEvent format.
/// This function is responsible for converting raw input events from the winit library into a format that the engine can understand and process.
/// ## Arguments
/// * `event` - A reference to a `WindowEvent` from the winit library.
/// ## Returns
/// * An `Option<InputEvent>` which will be `Some(InputEvent)` if the event is a recognized input event, or `None` if it is not.
pub(crate) fn translate_winit_input(event: &WindowEvent) -> Option<InputEvent> {

    match event {
        WindowEvent::KeyboardInput { event: key_event, .. } => {

            // Check if the key_event is a physical key event
            if let PhysicalKey::Code(keycode) = key_event.physical_key {

                // Get the event state in the case it's pressed or released event
                let key_code_str = map_keycode_to_string(keycode);
                match key_event.state {
                    ElementState::Pressed if !key_event.repeat => Some(InputEvent::KeyPressed { key_code: key_code_str }),
                    ElementState::Released => Some(InputEvent::KeyReleased { key_code: key_code_str }),
                    _ => None, // Ignore repeats and unknown states
                }
            } else { None } // Ignore non-physical keys for now
        }

        WindowEvent::CursorMoved { position, .. } => {
            Some(InputEvent::MouseMoved { x: position.x as f32, y: position.y as f32 })
        }

        WindowEvent::MouseInput { state, button, .. } => {
            let khora_button = map_mouse_button(*button);
            match state {
                ElementState::Pressed => Some(InputEvent::MouseButtonPressed { button: khora_button }),
                ElementState::Released => Some(InputEvent::MouseButtonReleased { button: khora_button }),
            }
        }

        WindowEvent::MouseWheel { delta, .. } => {
            let (mut dx, mut dy) = (0.0, 0.0);
            match delta {
                MouseScrollDelta::LineDelta(x, y) => { dx = *x; dy = *y; }
                MouseScrollDelta::PixelDelta(pos) => { dx = pos.x as f32; dy = pos.y as f32; }
            }

            // Only return the event if there is a non-zero scroll delta
            // This is to avoid unnecessary events when the scroll delta is zero.
            if dx != 0.0 || dy != 0.0 { 
                Some(InputEvent::MouseWheelScrolled { delta_x: dx, delta_y: dy }) 
            } else { 
                None 
            }
        }

        // Ignore other WindowEvents (Resized, Focused, etc.) as they are not input actions
        _ => None,
    }
}


// --- Private Helper Functions ---

/// Maps a winit KeyCode to a string representation.
/// ## Arguments
/// * `keycode` - The KeyCode from winit to be converted.
/// ## Returns
/// * A string representation of the keycode.
fn map_keycode_to_string(keycode: KeyCode) -> String {
    // Using Debug is simple and covers all keys.
    format!("{:?}", keycode)
    // Consider a more specific mapping later if needed for game logic keys (W, A, S, D, Space etc.)
}

/// Maps a winit MouseButton to the engine's internal MouseButton enum.
/// ## Arguments
/// * `button` - The MouseButton from winit to be converted.
/// ## Returns
/// * The corresponding MouseButton from the engine's internal enum.
fn map_mouse_button(button: WinitMouseButton) -> MouseButton {
    match button {
        WinitMouseButton::Left => MouseButton::Left,
        WinitMouseButton::Right => MouseButton::Right,
        WinitMouseButton::Middle => MouseButton::Middle,
        WinitMouseButton::Back => MouseButton::Back,
        WinitMouseButton::Forward => MouseButton::Forward,
        WinitMouseButton::Other(id) => MouseButton::Other(id),
    }
}


// --- Unit Tests for Input Translation ---
#[cfg(test)]
mod tests {
    use super::*;
    use winit::{dpi::PhysicalPosition, event::WindowEvent, keyboard::KeyCode};


    /// Test cases for translating keycodes to strings
    #[test]
    fn test_map_keycode_simple() {
        assert_eq!(map_keycode_to_string(KeyCode::KeyA), "KeyA");
        assert_eq!(map_keycode_to_string(KeyCode::Digit1), "Digit1");
        assert_eq!(map_keycode_to_string(KeyCode::Space), "Space");
    }

    /// Test cases for translating mouse buttons to the engine's internal representation
    #[test]
    fn test_map_mouse_button_standard() {
        assert_eq!(map_mouse_button(WinitMouseButton::Left), MouseButton::Left);
        assert_eq!(map_mouse_button(WinitMouseButton::Right), MouseButton::Right);
        assert_eq!(map_mouse_button(WinitMouseButton::Middle), MouseButton::Middle);
        assert_eq!(map_mouse_button(WinitMouseButton::Back), MouseButton::Back);
        assert_eq!(map_mouse_button(WinitMouseButton::Forward), MouseButton::Forward);
    }

    /// Test cases for translating other mouse buttons to the engine's internal representation
    #[test]
    fn test_map_mouse_button_other() {
        assert_eq!(map_mouse_button(WinitMouseButton::Other(8)), MouseButton::Other(8));
        assert_eq!(map_mouse_button(WinitMouseButton::Other(15)), MouseButton::Other(15));
    }

    /// Test cases for translating winit mouse press to engine's internal representation
    #[test]
    fn test_translate_mouse_button_pressed() {
        let winit_event = WindowEvent::MouseInput {
            device_id: winit::event::DeviceId::dummy(),
            state: ElementState::Pressed,
            button: WinitMouseButton::Left,
        };
        let expected = Some(InputEvent::MouseButtonPressed { button: MouseButton::Left });
        assert_eq!(translate_winit_input(&winit_event), expected);
    }

    /// Test cases for translating winit mouse release to engine's internal representation
    #[test]
    fn test_translate_mouse_button_released() {
        let winit_event = WindowEvent::MouseInput {
            device_id: winit::event::DeviceId::dummy(),
            state: ElementState::Released,
            button: WinitMouseButton::Right,
        };
        let expected = Some(InputEvent::MouseButtonReleased { button: MouseButton::Right });
        assert_eq!(translate_winit_input(&winit_event), expected);
    }

    /// Test cases for translating winit cursor movement to engine's internal representation
    #[test]
    fn test_translate_cursor_moved() {
        let winit_event = WindowEvent::CursorMoved {
            device_id: winit::event::DeviceId::dummy(),
            position: PhysicalPosition::new(100.5, 200.75),
        };
        let expected = Some(InputEvent::MouseMoved { x: 100.5, y: 200.75 });
        assert_eq!(translate_winit_input(&winit_event), expected);
    }

    /// Test cases for translating winit mouse wheel scroll to engine's internal representation
    #[test]
    fn test_translate_mouse_wheel_line() {
        let winit_event = WindowEvent::MouseWheel {
            device_id: winit::event::DeviceId::dummy(),
            delta: MouseScrollDelta::LineDelta(-1.0, 2.0),
            phase: winit::event::TouchPhase::Moved,
        };
        let expected = Some(InputEvent::MouseWheelScrolled { delta_x: -1.0, delta_y: 2.0 });
        assert_eq!(translate_winit_input(&winit_event), expected);
    }

    /// Test cases for translating winit mouse wheel scroll in pixels to engine's internal representation
    #[test]
    fn test_translate_mouse_wheel_pixel() {
        let winit_event = WindowEvent::MouseWheel {
            device_id: winit::event::DeviceId::dummy(),
            delta: MouseScrollDelta::PixelDelta(PhysicalPosition::new(5.5, -10.0)),
            phase: winit::event::TouchPhase::Moved,
        };
        let expected = Some(InputEvent::MouseWheelScrolled { delta_x: 5.5, delta_y: -10.0 });
        assert_eq!(translate_winit_input(&winit_event), expected);
    }

    /// Test cases for translating winit specific window events to engine's internal representation
    #[test]
    fn test_translate_non_input_returns_none() {
        let winit_event_resize = WindowEvent::Resized(winit::dpi::PhysicalSize::new(100, 100));
        let winit_event_focus = WindowEvent::Focused(true);
        let winit_event_close = WindowEvent::CloseRequested;
        assert_eq!(translate_winit_input(&winit_event_resize), None);
        assert_eq!(translate_winit_input(&winit_event_focus), None);
        assert_eq!(translate_winit_input(&winit_event_close), None);
    }
}
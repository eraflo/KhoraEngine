// Copyright 2025 eraflo
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! The AssetAgent is responsible for managing asset loading and retrieval.

use anyhow::{anyhow, Context, Result};
use khora_core::{
    asset::{Asset, AssetHandle, AssetUUID},
    vfs::VirtualFileSystem,
};
use khora_data::assets::Assets;
use khora_lanes::asset_lane::{AssetLoaderLane, PackLoadingLane};
use khora_telemetry::MetricsRegistry;
use std::{
    any::{Any, TypeId},
    collections::HashMap,
    fs::File, sync::Arc,
};

use crate::asset_agent::loader::AssetLoaderLaneRegistry;

/// The AssetAgent is responsible for managing asset loading and retrieval.
pub struct AssetAgent {
    /// The virtual file system for asset management.
    vfs: VirtualFileSystem,
    /// The loading lane for asset I/O operations.
    loading_lane: PackLoadingLane,
    /// The registry that manages asset loaders.
    loaders: AssetLoaderLaneRegistry,
    /// Type-erased storage for different types of loaded assets.
    /// Maps a TypeId to a Box<Any> that holds an `Assets<A>`.
    storages: HashMap<TypeId, Box<dyn Any + Send + Sync>>,
}

impl AssetAgent {
    /// Creates a new `AssetAgent` with the given VFS and loading lane.
    pub fn new(index_bytes: &[u8], data_file: File, metrics_registry: Arc<MetricsRegistry>) -> Result<Self> {
        let vfs = VirtualFileSystem::new(index_bytes)
            .context("Failed to initialize VirtualFileSystem from index bytes")?;

        let loading_lane = PackLoadingLane::new(data_file);

        Ok(Self {
            vfs,
            loading_lane,
            loaders: AssetLoaderLaneRegistry::new(metrics_registry),
            storages: HashMap::new(),
        })
    }

    /// Registers an `AssetLoaderLane` for a specific asset type name.
    ///
    /// The `type_name` should match the one generated by the `xtask` packager
    /// based on the file extension.
    pub fn register_loader<A: Asset>(
        &mut self,
        type_name: &str,
        loader: impl AssetLoaderLane<A> + Send + Sync + 'static,
    ) {
        self.loaders.register::<A>(type_name, loader);
    }

    /// Loads, decodes, and returns a typed handle to an asset.
    ///
    /// This is the main, fully-featured loading method.
    pub fn load<A: Asset>(&mut self, uuid: &AssetUUID) -> Result<AssetHandle<A>> {
        let type_id = TypeId::of::<A>();

        // --- 1. Get or create the specific storage for the asset type `A` ---
        let storage = self
            .storages
            .entry(type_id)
            .or_insert_with(|| Box::new(Assets::<A>::new()));

        // Downcast the `Box<dyn Any>` to `&mut Assets<A>`
        let assets = storage
            .downcast_mut::<Assets<A>>()
            .ok_or_else(|| anyhow!("Mismatched asset storage type"))?;

        // --- 2. Check if the asset is already cached ---
        if let Some(handle) = assets.get(uuid) {
            return Ok(handle.clone()); // Cache hit!
        }

        // --- 3. If not cached, load the asset (Cache miss) ---
        let metadata = self
            .vfs
            .get_metadata(uuid)
            .ok_or_else(|| anyhow!("Asset with UUID {:?} not found in VFS", uuid))?;

        let source = metadata
            .variants
            .get("default")
            .ok_or_else(|| anyhow!("Asset {:?} has no 'default' variant", uuid))?;

        let bytes = self.loading_lane.load_asset_bytes(source)?;

        let asset: A = self.loaders.load::<A>(&metadata.asset_type_name, &bytes)?;

        // --- 4. Create the handle and store it in the cache before returning ---
        let handle = AssetHandle::new(asset);
        assets.insert(*uuid, handle.clone());

        Ok(handle)
    }
}
